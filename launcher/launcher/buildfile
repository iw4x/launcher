libs =

options = launcher-options
schemas = cache/cache-types

import libs += libssl%lib{ssl}
import libs += libcrypto%lib{crypto}

import libs += libboost-asio%lib{boost_asio}
import libs += libboost-beast%lib{boost_beast}
import libs += libboost-filesystem%lib{boost_filesystem}
import libs += libboost-json%lib{boost_json}
import libs += libboost-process%lib{boost_process}
import libs += libboost-system%lib{boost_system}

import libs += libminiz%lib{miniz}

import libs += libftxui%lib{ftxui-component}
import libs += libftxui%lib{ftxui-dom}
import libs += libftxui%lib{ftxui-screen}

import libs += libodb%lib{odb}
import libs += libodb-sqlite%lib{odb-sqlite}

exe{iw4x-launcher}: {hxx ixx txx cxx}{**  -steam/steam-proton    \
                                          -launcher-steam-proton \
                                          -version               \
                                          -*-options             \
                                          -*-odb                 \
                                          -pregenerated/**}
exe{iw4x-launcher}: {h c}{**}
exe{iw4x-launcher}: {hxx}{version}
exe{iw4x-launcher}: {hxx cxx}{steam/steam-proton}: include = ($tclass == 'linux')
exe{iw4x-launcher}: {hxx cxx}{launcher-steam-proton}: include = ($tclass == 'linux')
exe{iw4x-launcher}: $libs testscript

# Version header generation.
#
hxx{version}: in{version} $src_root/manifest

# Build options.
#
cc.poptions =+ "-I$out_root" "-I$src_root"

# On Windows, we need the advanced API library for registry access (used
# for Steam path detection).
#
if ($tsys == 'win32-msvc')
  cxx.libs += Advapi32.lib

# CLI Options Generation (Development vs. Consumption)
#

# In the development build ($develop == true), we generate the C++ CLI parsers
# from the .cli definition files using the CLI compiler. We also copy the
# results to the 'pregenerated/' directory so they can be distributed.
#
# In the consumption build ($develop == false), we skip the generation step
# (to avoid requiring CLI on the user's machine) and just use the files
# from 'pregenerated/'.
#

## Consumption build ($develop == false).
#

# Use pregenerated versions.
#
exe{iw4x-launcher}: pregenerated/{hxx ixx cxx}{**}: include = (!$develop)

# If we are consuming, we need to look in the pregenerated directory first.
#
if! $develop
  cxx.poptions =+ "-I($src_base/pregenerated)" # Note: must come first.

# Distribute pregenerated versions only in the consumption build.
#
pregenerated/{hxx ixx cxx}{*}: dist = (!$develop)


## Development build ($develop == true).
#

# Include the generated files in the build.
#
exe{iw4x-launcher}: {hxx ixx cxx}{$options}: include = $develop
exe{iw4x-launcher}: {hxx ixx cxx}{$schemas-odb}: include = $develop

if $develop
  import! [metadata] cli = cli%exe{cli}

# Rule to generate C++ parser from .cli file.
#
for f: $options
{
  [string] b = $f

  # Strip the '-options' suffix to get the base name.
  #
  b = $replace($b, "-options", "")
  d = $directory($f)
  p = pregenerated/launcher

  <{hxx ixx cxx}{$f}>: cli{$b}
  {
    # In development, we want to distribute the result of this generation,
    # but we map it to the 'pregenerated/' directory in the distribution.
    #
    dist = ($develop ? $relative([dir_path] "$p/$d", $d) : false)
  }
}

# The ad-hoc rule for running the CLI compiler.
#
<{hxx ixx cxx}{~'/(.*)-options/'}>: cli{~'/\1/'} $cli
%
if $develop
{{
  t = $path($>[0]).t

  # Dynamic dependency tracking.
  #
  depdb dyndep --byproduct --file $t

  h = $path($>[0])
  i = $path($>[1])
  c = $path($>[2])

  d = $directory($h)
  p = $string($leaf($d, $out_root))

  # Note that we generate *-options.hxx/ixx/cxx from cli<$f> instead of
  # <$f>.hxx/ixx/cxx to avoid filename conflicts and keep the base name <$f>
  # reserved for our own implementation headers and sources.
  #
  options = -I $src_root                                            \
            --std c++11                                             \
            --include-prefix $p                                     \
            --guard-prefix $regex.replace($ucase($p), '[/\\]', '_') \
            --generate-specifier                                    \
            --generate-file-scanner                                 \
            --suppress-undocumented                                 \
            --cli-namespace launcher::cli                              \
            --exclude-base                                          \
            --include-with-brackets                                 \
            --output-suffix -options

  $cli $options --generate-dep --dep-file $t -o $d $path($<[0])

  # If the result differs from the pregenerated version, copy it over.
  #
  d = [dir_path] $src_base/pregenerated/$p

  dh = $d/$leaf($h)
  di = $d/$leaf($i)
  dc = $d/$leaf($c)

  if diff $dh $h >- && \
     diff $di $i >- && \
     diff $dc $c >-
  {
    exit
  }

  cp $h $dh
  cp $i $di
  cp $c $dc
}}

## ODB
#

if $develop
  import! [metadata] odb = odb%exe{odb}

for f: $schemas
{
  [rule_hint=cxx] libue{$f-meta}: $libs

  exe{iw4x-launcher}: libue{$f-meta} $libs

  <{hxx ixx cxx}{$f-odb}>: hxx{$f} libue{$f-meta} $odb
  {
    dist = ($develop ? $relative([dir_path] "pregenerated/launcher/$d", $d) : false)
  }
}

<{hxx ixx cxx}{~'/(.+)-odb/'}>: hxx{~'/\1/'} libue{~'/.+-meta/'} $odb
%
if $develop
{{
  pops = $cxx.lib_poptions($<[1])

  depdb hash $pops

  h = $path($>[0])
  i = $path($>[1])
  c = $path($>[2])

  d = $directory($h)
  p = $string($leaf($d, $out_root))

  options = --std c++17 --database sqlite -I $src_root              \
            --include-with-brackets --include-prefix $p             \
            --guard-prefix $regex.replace($ucase($p), '[/\\]', '_') \
            --generate-schema --generate-query                      \
            --output-dir $d

  $odb $options $pops $path($<[0])

  # If the result differs from the pregenerated version, copy it over.
  #
  d = [dir_path] $src_base/pregenerated/$p

  dh = $d/$leaf($h)
  di = $d/$leaf($i)
  dc = $d/$leaf($c)

  if diff $dh $h >- && \
     diff $di $i >- && \
     diff $dc $c >-
  {
    exit
  }

  cp $h $dh
  cp $i $di
  cp $c $dc
}}

#
##
